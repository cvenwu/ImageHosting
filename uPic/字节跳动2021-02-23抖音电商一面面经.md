

# 面试过程（57分钟）



## 面试官介绍

物流中台的业务部门

## 自我介绍

介绍的时候说Golang是去年11月份用到的

## 确定实习时长

问了一下老师以及学校学术方面是否允许，以及学校是否有任务允许

说自己在补小论文的实验，其他没有要求

## Golang用的多，你能说一下Golang的协程模型，它里面的并发机制是什么样的

博大之前给的：GMP是两级线程模型：用户有绑定内核线程，内核主要负责cpu调度，用户主要对接内核

## 关于协程和线程的区别和联系你怎么理解

**可以用创建、内存占用、切换这三个角度回答**

自己的回答：

线程就是内核级线程，需要内核态与用户态切换

协程就是用户级线程，着重点在于编程语言自己设计的调度器的效率高低，如果调度器做的好，并发会比线程好很多

​    从网上查找的：**协程是一种用户态的轻量级线程，**协程的调度完全由用户控制。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。

1. 解释一下概念
2. 从三个角度解释区别和联系：
   1. 创建：
   2. 内存占用：
   3. 切换：

## 协程效果好主要原因是在哪里

**博大给的答案：**

1. 开启协程成本低，内存栈占用少(原来一个进程可以占用几G，线程占用几M，将goroutine内存大小改为了几KB，从而我们可以大量的使用goroutine)

2. 并且协程之间切换成本没有线程切换成本高：就是这个goroutine执行完切换到下个goroutine的执行栈上去执行这个成本超级低，
3. GMP是两级线程模型：用户有绑定内核线程，内核主要负责cpu调度，用户主要对接内核

**自己的回答：**

不需要切换（❌）

内存占用很小（✅）

## 对于golang里面的channel你怎么理解

自己回答了有缓冲的与没缓冲的以及对应的特点

## 对于channel是线程安全的么

是安全的，

## 为什么是线程安全的

这个瞎回答说是顺序执行channel中的一个个操作，也就是一个个当成原子性操作去执行

## 对于channel来讲，如果你认为是一个原子性操作，那么什么样的步骤你认为是一个原子性的操作

自己说实现具体也没怎么看，自己按照自己的理解回答

## 对于数据结构里面，二叉树，二叉搜索树，B树，B+树，这四种树你能谈一下你的理解么

自己的回答：

二叉树分支只有两个

二叉搜索树比二叉树多了一个平衡，并且中序遍历是有序的，

B树与B+树是多路查找树，B+树之前自己在看mysql里面说的是层数会压很低，每一层都需要一次磁盘IO，我要定位一下数据是存放在数据库的哪个区域，如果用二叉搜索树，查找效率是logN，B+树会低很多，层数4-5层就可以容纳十几亿的数据了

## 那么对于mysql来说为什么采用b+树而不采用b树

自己说有效减少磁盘IO次数，可以提高

追问：B树同样也是一样的树高也可以做的很低呀，

B树占用内存比较大，B+树只是在叶子节点存放我们需要的数据

追问：占用很大内存怎么理解

B+树搜索经过路径中节点的时候，比如主键，只会保存主键的值，并不会保存其他列的记录信息，只是在最后到叶子节点的时候才会保存一整行的记录，所以B+树会比B树占用内存小，

追问：既然mysql索引是b+树，有一种特殊的索引是联合索引你知道么，

自己回答mysql没怎么复习，

追问：面试官说与mysql没关系，

只能说自己的理解了，也就是多个索引结合在一起，

 追问：那联合索引在b树，b+树的结构是怎么样的，查找过程你了解过么？

这个没有了解过

## TCP/IP协议总共分为几层，

回答：有5层，有4层，有OSI7层，

追问：5层是哪5层？

回答：….

追问：物理层解决什么问题

回答：传输数据比特流，屏蔽传输介质与物理设备的差异

追问：数据链路层解决什么问题

回答：将网络分为一个链路一个链路，一个链路也就是一个局域网，主要解决的是一个局域网内主机的通信，网络层解决不同网络主机的通信

追问：不同网络主机的通信？

回答：比如路由器会选择下一跳路由来进行访问，

追问：那我同一个主机不同程序之间接收数据包由哪一层来决定

回答：运输层，通过分用的机制，将数据分发到不同应用程序上

## 对于网络传输来讲，经常会遇到网络质量变差，网络抖动导致数据丢失，对于这种情况TCP怎么解决

回答了

TCP可靠性的几个机制：

1. 序列号
2. 确认应答
3. 窗口：流量窗口与拥塞窗口
4. 重传，比如超时重传还有快重传

追问：对于网络中发送的数据包的顺序是如何保证的

回答：通过一个窗口比如我发送的序号是500，长度50的数据包，窗口开始位置移动到551表示我下次收到的是551开始的数据

## tcp建连过程中为什么是三次握手

回答：...

追问：为什么断连的时候需要四次

## 数据库的隔离级别你了解过么

回答：了解

追问：有哪些隔离级别

回答：...

追问：读未提交为什么会读取到其他事务没有提交的数据，为什么会出现这个问题，

回答：瞎几把回答

追问：脏读的数据为什么没有被读取者进行相应的控制，在什么情况下会出现脏读

回答：就是可以访问到其他事务修改之后没有提交的数据

追问：那这个数据放在哪里

回答：这个没有深入了解过，因为自己之前看到过脏读就是可以访问到其他事务修改之后没有提交的数据，像可重复读和读已提交都是通过视图实现的(一个是每次执行sql语句的时候会执行视图，另一个就是事务启动的时候会执行视图)

追问：对于可重复读你了解过他是怎么去实现的么，这个视图是怎么样的一个概念

回答：视图就是一组逻辑操作合并在一起，之后我们调用视图

追问：那么这个视图我们怎么知道要查询哪些数据呢

回答：这个没有了解过

## redis你用过么

redis用过但是项目中没有用过，学习了几个命令也算是了解吧

## 我看你做了一个简易分布式缓存系统，你能大概介绍一下这个系统么【卡到了21分51秒】

回答：主要讲解了几个亮点（通过LRU缓存淘汰策略，并发是通过读写锁，get加读锁，put加写锁，分布式的话采用的是一个http的server与http的client(作为客户端)，server的话通过一个Map进行一致性哈希算法节点的映射，避免访问不均衡造成崩溃）… **todo:自己之后想一下怎么去讲解自己的项目**，**使用singleflight避免缓存击穿，single原理参考：https://geektutu.com/post/geecache-day6.html与https://blog.csdn.net/weixin_43183475/article/details/105093355，** ![image-20210308112150496](/Users/wuxiaowen/work/%E5%AE%9E%E4%B9%A0/%E8%87%AA%E5%B7%B1%E7%9A%84%E9%9D%A2%E8%AF%95%E5%8E%86%E7%A8%8B/image-20210308112150496.png)

追问：你刚才说的server端存的是什么？存的是你刚才说的一致性哈希的环么？server存的是一致性hash的环，会调用

回答：一致性哈希的环是均匀分散，我会为每个节点虚拟出很多个节点对应这个机器，将其均衡分布在这个环上，避免某一个机器挂掉，造成某一区间上的失效造成服务崩溃

追问：每个机子只负责环的一段的话，如果某一个节点故障导致本应该落在这个节点上的数据都落到其他节点上了，导致别的节点被压垮，这种问题你怎么解决，

```
后来查的资料:

1. 每个虚拟节点添加一个备用机
2. 其实这个属于雪崩，通过配虚节点，也就是一个主机映射N个节点，下面的例子中默认映射100个节点，处理能力较强的主机可以配200或者更高的虚节点数量。
3. 对于缓存击穿，也就是如果某个key不存在，大家都去数据库查询，使用singleflight，也就是只有一个协程去访问数据，其他的都要等待，等访问之后其他的再进行访问，就会发现已经缓存了，有点类似于分布式锁的机制。
```
回答：自己当时做的只是将其分散，如果挂掉了之后就去查数据库，这个没有做，最开始的想法就是分散之后分布均匀，如果出现这种问题，就将虚拟节点建立的尽可能的多，分布在那个机器上的可能性就会小，造成服务器的压力就会小

追问：那么最终你没有实现这个问题的解决方案对吧？

回答：是的，当时做的时候没有考虑到这个问题

追问：你这种读写锁的方式去提供缓存的读写控制，性能怎么样

回答：我是用的那个（说的是wirk工具，但是其实是wrk压测工具），我是用笔记本测试是3000左右的QPS，大概是在2月初测的，当时赶论文，这个有点忘记了

追问：你这种测的话，你的数据分布怎么造，都是重复请求一个数据么，还是会采用不同的数据分批去访问

回答：我是用的一个大文件初始化的时候分布在不同的节点上

追问：那你有没有测过热点数据的访问，性能怎么样

回答：没有测过

追问：那对于热点数据的访问，你的解决方案是什么样的，热点的key
```
事后百度：1. **监控热点key**，使用二级缓存， 2. 备份热点key到不同的节点上，不要只放到一个节点上，

对于热点key问题，我们只需要两步处理：

**1、监控热点key**

**2、通知系统做处理**

如果热key过来之后首先判断key是否是热key，如果是的话，就将其缓存到热key对应的缓存空间中，自己因为缓存里面有不同的命名空间，所以可以用于新建一个命名空间来存热key，甚至我们可以将热key分发到各个节点的机器。
```


回答：没做，自己当时做的就是分散在每个节点上，但是如果有热点的话，我们自己可以建一个数据结构然后映射到我们经常用的热点数据里面，比如映射到经常使用的高频里面，类似于redis里面的hash映射，key就是访问的key，value就是访问的节点

追问：你采用的LRU访问策略是吧，你怎么统计LRU的访问频次，怎么实现的？

回答：这个当时没有做，就是经常访问放到链表的头部，如果要做的话可以加一个次数的属性到节点中

追问：你现在LRU采用的是什么数据结构？

回答：map + 双链表

追问：这样单纯LRU的实现，来存经常访问的数据会不会有问题，就是说的是准确性问题，比如我们经常访问一个数据，他可能是最常访问的，但是新来一个数据，新来之后会把他干掉，对于这种情况，你有什么解决办法么

回答：我觉得是否可以加一个桶的机制，每一个桶对应几个节点，然后每个桶对应一个链表，然后每次去桶里面查找

追问：那你这个计算桶里面的访问次数对于他的排序有什么帮助么？

回答：其实也没有什么帮助，只是突然间这么想的

## 好的我们要不做道题吧

## 算法题【两道选一个】31分开始选题

### 给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。

示例 1：

输入: "babad"
输出: "bab"
注意: "aba" 也是一个有效答案。

示例 2：

输入: "cbbd"
输出: "bb"

### 给定一个字符串，请你找出其中不含有重复字符的 最长子串。


示例 1:
输入: s = "abcabcbb"
输出: "abc"
解释: 因为无重复字符的最长子串是 "abc"。

示例 2:
输入: s = "bbbbb"
输出: "b"
解释: 因为无重复字符的最长子串是 "b"。

示例 3:
输入: s = "pwwkew"
输出: "wke"
解释: 无重复字符的最长子串是 "wke"。
请注意，你的答案必须是 子串，"pwke" 是一个子序列，不是子串。

示例 4:
输入: s = ""
输出: ""

## 

> 最终选择了第二个，[LeetCode第3题无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)，自己之前做过，差点没想起来

在48分做完并提交

**进阶：后面面试官追问：如果我的字符不是ascii编码如何做呢，比如Unicode编码，自己说了采用对应长度的二进制，可能不是很好的答案吧。**

自己当时写的代码：运行环境go1.14.4

```go
package main

import (
    "fmt"
)


//思路：滑动窗口
func demo(s string) string {
    if len(s) <= 1 {
        return s
    }
    //返回的结果对应的最长子串
    ret := string(s[0])
    //最长子串的长度
    max := 1
    //子串的长度
    length := 1
    
    hmap := make(map[byte]bool)
    window := []byte{s[0]}
    cur := 1
    hmap[s[cur]] = true
    for cur < len(s) {
        //判断当前字符是否已经在窗口中
        //如果在窗口中我们需要将窗口左侧的数据不断移除，直到当前字符不在窗口中
        
        for {
            if _, ok := hmap[s[cur]]; ok {
                key := window[0]
                window = window[1:]
                delete(hmap, key)
                length--
            }
            break
        }
        
        
        //此时将当前字符加入到窗口中
        hmap[s[cur]] = true
        window = append(window, s[cur])
        length += 1
        //动态更新最长子串
        if length > max {
            max = length
            ret = string(window)
        }
        cur++
    }
    return ret
}

func main() {
    //a := 0
    fmt.Println(demo("abcabcbb"))
        fmt.Println(demo("bbbbb"))

        fmt.Println(demo("pwwkew"))

}
```

